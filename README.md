# react-2
<h1>202330117 송예진</h1>
<hr>

## 🔖 10월 1일 (6주차)
<h2> Client-side transitions(클라이언트 측 전환)</h2>

- 서버 렌더링 페이지로 이동하면 전체 페이지가 로드됨
- 이로 인해 state가 삭제되고, 스크롤 위치가 재설정되며, 상호작용이 차단됨
- <Link> 컴포넌트를 사용하는 클라이언트 측 전환을 통해 이를 방지
 콘텐츠를 동적으로 업데이트
-  공유 레이아웃과 UI를 유지
- 미리 가져온 로딩 상태 또는 사용 가능한 경우 새 페이지
- 서버에서 렌더링된 앱을 클라이언트에서 렌더링된 앱처럼 느껴지게 하는 요소
- 프리패칭 및 스트리밍과 함께 사용하면 동적 경로에서도 빠른 전환 가능

<h2> generateStaticParams가 없는 경우와 있는 경우 비교</h2>

- 없는 경우 Next.js는 slug값을 빌드 타임에는 모르는 상태
- 요청할 때마다 해당 페이지를 동적으로 렌더링
- 있는 경우 빌드타입에 생성할 slug 목록을 알려줌
- 정적html+ json 빌드 타임이 생성, 최초 접근 시 SSR이 필요 없이 미리 만들어진 페이지 제공

<h2> 느린 네트워크 </h2>

- 클릭하기 전에 프리페칭이 완료되지 않을 수 있음
- 정적 경로와 동적 경로 모두 영향
- loading.tsx 파일이 아직 프리페칭되지 않았기 때문에 즉시 표시되지 않을 수 있음
- useLinkStatus Hook을 사용




## 🔖 9월 24일 (5주차)
<h2> searchParams란? </h2>

- url의 쿼리 문자열을 읽는 방법
- searchParams는 컴포넌트의 props로 전달되며, 내부적으로는 URLSearchParams처럼 작동함

<h2> Linking between pages(페이지 간 연결) </h2>

- <Link> 컴포넌트를 사용하여 경로 사이를 탐색
- HTML <a>태그를 확장하여 prefetching 및 client-side navigation 기능을 제공하는 
 
<h2> 초입 </h2>

- 경로는 기본적을 서버에서 렌더링됨
- 새 경로를 표시하기 전에 서버의 응답을 기다려야 하는 경우가 많음
- perfetching, streaming, client-side-transition(클라이언트 사이드 전환) 기능이 기본 제공되어 네비게이션 속도가 빠르고 반응성이 뛰어남
- 네비게이션이 작동하는 방식, 동적 라우트와 느린 네트워크에 맞게 네비게이션을 최적화하는 방법을 설명

<h2>Streaming(스트리밍)</h2>

- 전체 경로가 렌더링될 때까지 기다리지 않고, 동적 경로의 일부가 준비되는 즉시 클라이언트에 전송할 수 있음
- 동적 경로의 경우, 부분적으로 미리 가져올 수 있다는 뜻
- 공유 레이아웃과 로딩 스켈레톤을 미리 요청


## 🔖 9월 17일 (4주차)
<h2>git checkout vs git switch 차이</h2>

- checkout은 브랜치를 이동하고 파일도 바꿀 수 있음. 실수할 위험성 있음
- switch는 브랜치만 이동. 안전하게 사용 가능
- switch는 이미 작성된 commit을 조작하는 것만 할 수 없는 것이지 나머지 작업, 즉 파일을 작성하고, 수정하고, 커밋하는 것은 가능
- 특별한 이유가 없다면 switch 사용

<h2>Creating a nested route(중첩 라우트 만들기)</h2>
- 중첩 라우트는 다중 URL 세그먼트로 구성된 라우트입니다.

### [Next.js에서]
- 폴더는 URL 세그먼트에 매핑되는 경로 세그먼트를 정의하는데 사용됨. 즉, 폴더가 URL 세그먼트가 됨
- 파일은 세그먼트에 표시되는 UI를 만드는 데 사용됨
- 폴더를 중첩하면 중첩된 라우트를 만들 수 있음

<h2>3. Creating a nested route(중첩 라우트 만들기)</h2>
- 폴더를 계속 중첩하여 중첩된 경로 생성 가능
- 블로그 게시물에 대한 경로를 만드려면 blog 안에 새 [slug] 폴더를 만들고 page  파일을 추가
- 폴더 이름을 대괄호로 묶으면 데이터에서 여러 페이지를 생성하는데 사용되는 동적 경로 세그먼트가 생성됨

<h2>6. Rendering with search params(검색 매개변수를 사용한 렌더링)</h2>
- 서버 컴포넌트를 page에서는 searchParams prop을 사용하여 검색 매개변수에 액세스
- searchParams를 사용하면 해당 페이지는 동적 렌더링 처리됨
- URL의 쿼리 파라미터를 읽기 위해 요청이 필요하기 때문


## 🔖 9월 10일 (3주차)
<h2>1. Folder and file conventions(폴더 및 파일 규칙)</h2>

###  [최상위 폴더] Top-level folders
- 최상위 폴더는 애플리케이션의 코드와 정적 자산을 구성하는 데 사용됨

###  [최상위 파일] Top-level files
- 최상위 파일은 애플리케이션 구성, 종속성 관리, 미들웨어 실행, 모니터링 도구 통합, 환경 변수 정의에 사용

<h2>2. Organizing your project(프로젝트 구성하기)</h2>

- Next.js는 프로젝트 파일을 어떻게 구성하고 어디에 배치할지에 대한 제약이 없음

<h2>layout과 template의 차이</h2>

- layout: 경로별 공유 레이아웃, 상태/dom 유지됨 (정적), 네비게이션,사이드바, 공통 레이아웃
- template: 매번 새 인스턴스 생성, 상태/dom 유지됨 초기화됨(동적), 페이지별로 초기화가 필요한

- component는 중첩된 라우팅에서 재귀적으로 렌더링 됨
- 즉, 라우팅 세그먼트의 component는 부모 세그먼트의 component 재부에 중첩됨
- 세그먼트는 나누어진 각 부분, 분할된 부분, 또는 특정 기준에 따라 분류된 그룹을 의미
- 즉, 프로젝트 파일을 app 디렉토리의 라우팅 세그먼트 내에 안전하게 배치하여 실수로 라우팅되지 않도록 할 수 있음
- 원한다면 app 디렉토리 외부에 보관할 수도 있음
- app 디렉토리의 파일은 기본적으로 안전하게 코로케이션 될 수 있으므로, 코로케이션에 비공개 폴더는 불필요함.
- UI 로직과 라우팅 로직을 분리
- 내부 파일을 일관되게 구성
- 파일을 정렬하고 그룹화
- 이름 충돌을 방지

### 알아두면 좋은 정보
- 밑줄 패턴을 사용하여 비공개 폴더 외부의 파일을 "비공개"로 표시
- 비공개 폴더를 사용하지 않는 경우, 예상치 못한 이름 충돌 방지를 위해 Next.js의 특수 파일 규칙을 아는것이 좋음


###  [라우팅 그룹] Route groups
- 폴더를 괄호로 묶어 라우팅 그룹을 만들 수 있음(folderName)
- 구성 목적을 사용되는 것을 의미, 라우터의 URL 경로에 포함되지 않아야 함

- 파일을 어떻게 구성하고 어디에 배치할지에 대한 제약이 없음
- 도움이 되는 몇 가지 기능을 제공

## 🔖 9월 3일 (2주차)
<h2>Installation</h2>

- 명령팔레트 -> "TypeScript: TypeScript 버전 선택" -> select version
- Next.js에는 ESLint가 내장되어 있음
- 기존 프로젝트에 ESLint를 수동으로 추가하려면 package.json에 next lint 스크립트를 추가해야함 <br>
<p style="
color: black;background:#cfcfcf;
border-radius:5px;
padding:15px;
">
{<br>
&emsp; "scripts": {<br>&emsp;&emsp;&emsp;
            "lint": "next lint"<br>
&emsp;&emsp;&emsp;    }<br>
}
</p>
#### 7. import 및 모듈의 절대 경로 별칭 설정
- Next.js에는 tsconfig.json 및 jsconfig.json 파일의 "paths" 및 "baseUrl" 옵션에 대한 지원을 내장
- 프로젝트 디렉터리를 절대 경로로 별칭하여 모듈을 더 쉽고 깔끔하게 가져올 수 있음

#### 부트스트랩 이용

### Core Web Vitals
- LcP: 뷰포트 내에서 가장 큰 페이지 요소를 표시하는데 걸리는 시간
- FID: 사용자가 웹페이지와 상호작용을 시도하는 첫 번째 순간부터 웹페이지가 응답하는 순간
- CLS: 방문자에게 콘텐츠가 얼마나 불안정한 지 측정한 값, 레이아웃 이동 빈도를 측정

### 하드링크 vs 심볼릭 링크

#### 하드링크
- Directory Entry: 파일 이름과 해당 inode 번호를 매핑 정보가 있는 특수한 파일
- inode: 파일 또는 디렉토리에 대한 모든 메타데이터를 저장하는 구조체

#### 심볼릭 링크
- 경로 문자열을 저장해 두는 특수 파일
- 경로를 따라가서 원본 파일을 찾음
- 원본이 삭제되면 심볼릭 링크는 끊어진 경로가 되므로 더 이상 사용할 수 없음
- 윈도우의 바로 가기 파일과 비슷하게 생각할 수 있음

### 실습에 사용할 프로젝트 생성
1. 프로젝트 이름 입력
2. TypeScript, ESLint, Tailwind를 사용할지 선택
3. src/디렉토리 사용할지 선택
4. App Router 사용할지 선택
5. import alias 사용할지 선택
6. alias 문자를 지정 기본은 @/*

## 🔖 8월 27일 (1주차)
- OT진행
- 프로그램 설치
